// SPDX-FileCopyrightText: 2025 itiquette/gommitlint <https://github.com/itiquette/gommitlint>
//
// SPDX-License-Identifier: EUPL-1.2

package cli

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/itiquette/gommitlint/internal/adapters/cli/testdata"
	gitTestdata "github.com/itiquette/gommitlint/internal/adapters/git/testdata"
)

// TestHookInstallationParameters tests the HookInstallationParameters type.
func TestHookInstallationParameters(t *testing.T) {
	// Create a test Git repository
	tmpDir, cleanup := gitTestdata.GitRepo(t, "Initial commit")
	defer cleanup()

	// Test the basic parameters
	params := NewHookInstallationParameters(false, tmpDir)
	params.PathValidator = testdata.SimplePathValidator{} // Use simple validator for tests
	require.False(t, params.Force)
	require.Equal(t, tmpDir, params.RepoPath)
	require.Equal(t, "commit-msg", params.HookType)

	// Test immutability with methods
	forceParams := params.WithForce()
	require.False(t, params.Force, "Original should be unchanged")
	require.True(t, forceParams.Force, "New instance should have updated value")

	noForceParams := forceParams.WithoutForce()
	require.True(t, forceParams.Force, "Original should be unchanged")
	require.False(t, noForceParams.Force, "New instance should have updated value")

	customHookParams := params.Hook("custom-hook")
	require.Equal(t, "commit-msg", params.HookType, "Original should be unchanged")
	require.Equal(t, "custom-hook", customHookParams.HookType, "New instance should have updated value")

	customRepoParams := params.Repo("/custom/path")
	require.Equal(t, tmpDir, params.RepoPath, "Original should be unchanged")
	require.Equal(t, "/custom/path", customRepoParams.RepoPath, "New instance should have updated value")

	// Test the methods
	hookPath, err := params.FindHookPath()
	require.NoError(t, err)
	require.Contains(t, hookPath, ".git/hooks/commit-msg")

	err = params.EnsureHooksDirectory()
	require.NoError(t, err)

	content := params.GetHookContent()
	require.Contains(t, content, "gommitlint")

	// Test CanInstallHook with a clean repo (should be ok to install)
	err = params.CanInstallHook()
	require.NoError(t, err)

	// Create a hook and then test with force=false (should fail) and force=true (should pass)
	hooksDir := filepath.Join(tmpDir, ".git", "hooks")
	err = os.MkdirAll(hooksDir, 0755)
	require.NoError(t, err)

	err = os.WriteFile(
		filepath.Join(hooksDir, "commit-msg"),
		[]byte("#!/bin/sh\necho 'existing hook'\n"),
		0600,
	)
	require.NoError(t, err)

	// Without force
	err = params.CanInstallHook()
	require.Error(t, err)

	// With force
	forceParams = params.WithForce()

	err = forceParams.CanInstallHook()
	require.NoError(t, err)
}

func TestInstallHook(t *testing.T) {
	// Create a test Git repository
	tmpDir, cleanup := gitTestdata.GitRepo(t, "Initial commit")
	defer cleanup()

	// Define table-driven test cases
	tests := []struct {
		name          string
		repoPath      string
		force         bool
		setupFunc     func(repoDir string) error
		expectedError bool
		checkFunc     func(t *testing.T, repoDir string)
	}{
		{
			name:     "successful_commit_msg_hook",
			repoPath: tmpDir,
			force:    false,
			setupFunc: func(_ string) error {
				return nil // No special setup needed
			},
			expectedError: false,
			checkFunc: func(t *testing.T, repoDir string) {
				t.Helper()
				hookPath := filepath.Join(repoDir, ".git", "hooks", "commit-msg")
				content, err := os.ReadFile(hookPath)
				require.NoError(t, err)
				require.Contains(t, string(content), "Generated by gommitlint install-hook command")

				// Check executable permissions (0700)
				info, err := os.Stat(hookPath)
				require.NoError(t, err)
				require.Equal(t, os.FileMode(0700), info.Mode()&0777)
			},
		},
		{
			name:     "fails_with_existing_hook_no_force",
			repoPath: tmpDir,
			force:    false,
			setupFunc: func(repoDir string) error {
				t.Helper()
				// Create a pre-existing hook
				hooksDir := filepath.Join(repoDir, ".git", "hooks")
				err := os.MkdirAll(hooksDir, 0755)
				if err != nil {
					return err
				}

				return os.WriteFile(
					filepath.Join(hooksDir, "commit-msg"),
					[]byte("#!/bin/sh\necho 'existing hook'\n"),
					0600,
				)
			},
			expectedError: true,
			checkFunc: func(t *testing.T, repoDir string) {
				t.Helper()
				// The existing hook should remain unchanged
				hookPath := filepath.Join(repoDir, ".git", "hooks", "commit-msg")
				content, err := os.ReadFile(hookPath)
				require.NoError(t, err)
				require.Contains(t, string(content), "existing hook")
			},
		},
		{
			name:     "overwrites_existing_hook_with_force",
			repoPath: tmpDir,
			force:    true,
			setupFunc: func(repoDir string) error {
				t.Helper()
				// Create a pre-existing hook
				hooksDir := filepath.Join(repoDir, ".git", "hooks")
				err := os.MkdirAll(hooksDir, 0755)
				if err != nil {
					return err
				}

				return os.WriteFile(
					filepath.Join(hooksDir, "commit-msg"),
					[]byte("#!/bin/sh\necho 'existing hook'\n"),
					0600,
				)
			},
			expectedError: false,
			checkFunc: func(t *testing.T, repoDir string) {
				t.Helper()
				// The hook should be overwritten with our version
				hookPath := filepath.Join(repoDir, ".git", "hooks", "commit-msg")
				content, err := os.ReadFile(hookPath)
				require.NoError(t, err)
				require.Contains(t, string(content), "Generated by gommitlint install-hook command")
			},
		},
	}

	for _, testCase := range tests {
		t.Run(testCase.name, func(t *testing.T) {
			// Set up the test case
			err := testCase.setupFunc(tmpDir)
			require.NoError(t, err)

			// Execute the function being tested
			err = installHook(testCase.force, testCase.repoPath)

			// Check the result
			if testCase.expectedError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
			}

			// Additional verification
			testCase.checkFunc(t, tmpDir)
		})
	}
}
