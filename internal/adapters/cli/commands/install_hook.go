// SPDX-FileCopyrightText: 2025 itiquette/gommitlint <https://github.com/itiquette/gommitlint>
//
// SPDX-License-Identifier: EUPL-1.2

package commands

import (
	"context"
	"fmt"
	"os"

	cliAdapter "github.com/itiquette/gommitlint/internal/adapters/cli"
	logadapter "github.com/itiquette/gommitlint/internal/adapters/logging"
	"github.com/itiquette/gommitlint/internal/adapters/signing"
	"github.com/urfave/cli/v3"
)

// NewInstallHookCommand creates the install-hook subcommand.
func NewInstallHookCommand() *cli.Command {
	return &cli.Command{
		Name:  "install-hook",
		Usage: "Install Git commit-msg hook for validation",
		Description: `Installs a Git commit-msg hook to automatically validate commit messages.

Examples:
  # Install commit-msg hook in the current repository
  gommitlint install-hook

  # Install commit-msg hook with force
  gommitlint install-hook --force`,

		Flags: []cli.Flag{
			&cli.BoolFlag{
				Name:    "force",
				Aliases: []string{"f"},
				Usage:   "overwrite existing hook if it exists",
			},
		},

		Action: func(ctx context.Context, cmd *cli.Command) error {
			return ExecuteInstallHook(ctx, cmd)
		},
	}
}

// ExecuteInstallHook orchestrates the hook installation process.
func ExecuteInstallHook(ctx context.Context, cmd *cli.Command) error {
	// Get flags
	force := cmd.Bool("force")
	repoPath := getRepoPath(cmd)

	// Create logger from context
	zerologLogger := logadapter.GetLogger(ctx)
	logger := logadapter.NewDomainLogger(zerologLogger)

	// Install the hook
	if err := installHook(force, repoPath); err != nil {
		logger.Error("Hook installation failed", "error", err)

		return err
	}

	fmt.Fprintln(cmd.Writer, "âœ… Git commit-msg hook installed successfully!")

	return nil
}

// installHook installs a Git commit-msg hook in the specified repository.
func installHook(force bool, repoPath string) error {
	// Validate and normalize the repository path using signing utilities
	validatedPath, err := signing.ValidateGitRepoPath(repoPath)
	if err != nil {
		return fmt.Errorf("invalid repository path: %w", err)
	}

	// Create parameters with defaults
	params := NewHookInstallationParameters(force, validatedPath)

	// Ensure hooks directory exists
	if err := EnsureHooksDirectory(params.RepoPath, params.PathValidator); err != nil {
		return err
	}

	// Check if we can install the hook
	if err := params.CanInstallHook(); err != nil {
		return err
	}

	// Get the hook path
	hookPath, err := FindHookPath(params.RepoPath, params.HookType, params.PathValidator)
	if err != nil {
		return err
	}

	// Get the hook content
	hookContent := params.GetHookContent()

	// Write the hook file using our secure file writing function
	if err := signing.SafeWriteFile(hookPath, []byte(hookContent), 0700); err != nil {
		return fmt.Errorf("could not write hook file: %w", err)
	}

	return nil
}

// HookInstallationParameters contains all parameters needed for hook installation.
type HookInstallationParameters struct {
	Force         bool
	RepoPath      string
	HookType      string
	PathValidator cliAdapter.PathValidator
}

// NewHookInstallationParameters creates HookInstallationParameters with defaults.
func NewHookInstallationParameters(force bool, repoPath string) HookInstallationParameters {
	// Default to commit-msg hook type (currently the only supported type)
	return HookInstallationParameters{
		Force:         force,
		RepoPath:      repoPath,
		HookType:      "commit-msg",
		PathValidator: cliAdapter.DefaultPathValidator(),
	}
}

// GetHookContent returns the content for the hook based on its type.
func (p HookInstallationParameters) GetHookContent() string {
	// Currently, only commit-msg hooks are supported
	return generateCommitMsgHook()
}

// CanInstallHook checks if a hook can be installed based on parameters.
func (p HookInstallationParameters) CanInstallHook() error {
	hookPath, err := FindHookPath(p.RepoPath, p.HookType, p.PathValidator)
	if err != nil {
		return err
	}

	// Check if hook already exists using file descriptor to prevent TOCTOU
	file, err := os.Open(hookPath)
	if err == nil {
		// File exists
		file.Close()

		if !p.Force {
			return fmt.Errorf("hook already exists at %s (use --force to overwrite)", hookPath)
		}
	} else if !os.IsNotExist(err) {
		// Some other error occurred
		return fmt.Errorf("cannot check hook existence: %w", err)
	}

	return nil
}

// generateCommitMsgHook generates content for the commit-msg hook.
func generateCommitMsgHook() string {
	return createDefaultHookScript()
}

// createDefaultHookScript creates a shell script for the commit-msg hook.
func createDefaultHookScript() string {
	return `#!/bin/sh
#
# gommitlint commit-msg hook for validating commit messages.
# Generated by gommitlint install-hook command.
#
# To bypass this hook in emergencies:
#   git commit --no-verify
#
# Environment variables:
#   GOMMITLINT_DEBUG=1  Enable debug output
#   NO_COLOR=1          Disable colored output
#

set -e

# Get the commit message file path
COMMIT_MSG_FILE=$1

# Check if gommitlint is available
if ! command -v gommitlint >/dev/null 2>&1; then
    echo "Error: gommitlint not found in PATH" >&2
    echo "Please ensure gommitlint is installed and in your PATH" >&2
    echo "See: https://github.com/itiquette/gommitlint#installation" >&2
    exit 1
fi

# Build command flags
FLAGS=""

# Handle color output
if [ -n "$NO_COLOR" ] || [ ! -t 1 ]; then
    FLAGS="$FLAGS --color=never"
fi

# Handle debug mode
if [ -n "$GOMMITLINT_DEBUG" ]; then
    FLAGS="$FLAGS --debug"
fi

# Run validation
if gommitlint validate --message-file="$COMMIT_MSG_FILE" $FLAGS; then
    exit 0
else
    echo "" >&2
    echo "Commit rejected due to message validation errors." >&2
    echo "" >&2
    echo "Options:" >&2
    echo "  - Fix the issues above and try again" >&2
    echo "  - Run 'gommitlint config show' to see active rules" >&2
    echo "  - Use 'git commit --no-verify' to bypass (not recommended)" >&2
    exit 1
fi
`
}
